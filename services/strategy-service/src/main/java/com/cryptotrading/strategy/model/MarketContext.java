package com.cryptotrading.strategy.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * Market context for Drools rule evaluation
 * Contains all market data and technical indicators needed for strategy decisions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MarketContext {

    // Basic Market Data
    private String symbol;
    private LocalDateTime timestamp;
    private BigDecimal currentPrice;
    private BigDecimal volume;
    private BigDecimal high24h;
    private BigDecimal low24h;
    private BigDecimal change24h;
    private BigDecimal changePercent24h;

    // Technical Indicators
    private BigDecimal rsi;
    private BigDecimal macd;
    private BigDecimal macdSignal;
    private BigDecimal macdHistogram;
    
    // Moving Averages
    private BigDecimal sma5;
    private BigDecimal sma10;
    private BigDecimal sma20;
    private BigDecimal sma50;
    private BigDecimal sma200;
    private BigDecimal ema12;
    private BigDecimal ema26;
    private BigDecimal ema50;
    
    // Bollinger Bands
    private BigDecimal bollingerUpper;
    private BigDecimal bollingerMiddle;
    private BigDecimal bollingerLower;
    private BigDecimal bollingerWidth;
    
    // Stochastic
    private BigDecimal stochasticK;
    private BigDecimal stochasticD;
    
    // Volume Indicators
    private BigDecimal vwap;
    private BigDecimal volumeRatio;
    private BigDecimal onBalanceVolume;
    
    // Volatility
    private BigDecimal atr;
    private BigDecimal volatility;
    
    // Prediction Models
    private BigDecimal arimaPrediction;
    private BigDecimal mlPrediction;
    private BigDecimal trendPrediction;
    private BigDecimal predictionConfidence;
    
    // Market Sentiment
    private BigDecimal fearGreedIndex;
    private BigDecimal socialSentiment;
    
    // Cross-Exchange Data
    private BigDecimal arbitrageOpportunity;
    private BigDecimal liquidityScore;
    
    // Generated Signals (populated by Drools rules)
    @Builder.Default
    private List<TradingSignal> generatedSignals = new ArrayList<>();
    
    // Market Conditions
    private MarketTrend trend;
    private MarketVolatility volatilityLevel;
    private MarketLiquidity liquidityLevel;
    
    /**
     * Market trend enumeration
     */
    public enum MarketTrend {
        STRONG_UPTREND,
        UPTREND,
        SIDEWAYS,
        DOWNTREND,
        STRONG_DOWNTREND
    }
    
    /**
     * Market volatility levels
     */
    public enum MarketVolatility {
        VERY_LOW,
        LOW,
        NORMAL,
        HIGH,
        VERY_HIGH
    }
    
    /**
     * Market liquidity levels
     */
    public enum MarketLiquidity {
        VERY_LOW,
        LOW,
        NORMAL,
        HIGH,
        VERY_HIGH
    }
    
    /**
     * Add a trading signal generated by rules
     */
    public void addSignal(TradingSignal signal) {
        if (generatedSignals == null) {
            generatedSignals = new ArrayList<>();
        }
        generatedSignals.add(signal);
    }
    
    /**
     * Check if RSI indicates oversold condition
     */
    public boolean isRsiOversold() {
        return rsi != null && rsi.compareTo(BigDecimal.valueOf(30)) <= 0;
    }
    
    /**
     * Check if RSI indicates overbought condition
     */
    public boolean isRsiOverbought() {
        return rsi != null && rsi.compareTo(BigDecimal.valueOf(70)) >= 0;
    }
    
    /**
     * Check if MACD shows bullish crossover
     */
    public boolean isMacdBullishCrossover() {
        return macd != null && macdSignal != null && 
               macd.compareTo(macdSignal) > 0 && 
               macdHistogram != null && macdHistogram.compareTo(BigDecimal.ZERO) > 0;
    }
    
    /**
     * Check if MACD shows bearish crossover
     */
    public boolean isMacdBearishCrossover() {
        return macd != null && macdSignal != null && 
               macd.compareTo(macdSignal) < 0 && 
               macdHistogram != null && macdHistogram.compareTo(BigDecimal.ZERO) < 0;
    }
    
    /**
     * Check if price is above moving average
     */
    public boolean isPriceAboveSMA(BigDecimal sma) {
        return currentPrice != null && sma != null && currentPrice.compareTo(sma) > 0;
    }
    
    /**
     * Check if price is below moving average
     */
    public boolean isPriceBelowSMA(BigDecimal sma) {
        return currentPrice != null && sma != null && currentPrice.compareTo(sma) < 0;
    }
    
    /**
     * Check if price is near Bollinger Band upper
     */
    public boolean isNearBollingerUpper() {
        if (currentPrice == null || bollingerUpper == null) {
            return false;
        }
        BigDecimal threshold = bollingerUpper.multiply(BigDecimal.valueOf(0.98)); // Within 2%
        return currentPrice.compareTo(threshold) >= 0;
    }
    
    /**
     * Check if price is near Bollinger Band lower
     */
    public boolean isNearBollingerLower() {
        if (currentPrice == null || bollingerLower == null) {
            return false;
        }
        BigDecimal threshold = bollingerLower.multiply(BigDecimal.valueOf(1.02)); // Within 2%
        return currentPrice.compareTo(threshold) <= 0;
    }
    
    /**
     * Check if volume is above average
     */
    public boolean isHighVolume() {
        return volumeRatio != null && volumeRatio.compareTo(BigDecimal.valueOf(1.5)) > 0;
    }
    
    /**
     * Check if there's a strong prediction signal
     */
    public boolean hasStrongPredictionSignal() {
        return predictionConfidence != null && predictionConfidence.compareTo(BigDecimal.valueOf(0.8)) >= 0;
    }
    
    /**
     * Check if predictions are bullish
     */
    public boolean arePredictionsBullish() {
        if (currentPrice == null) {
            return false;
        }
        
        int bullishCount = 0;
        int totalPredictions = 0;
        
        if (arimaPrediction != null) {
            totalPredictions++;
            if (arimaPrediction.compareTo(currentPrice) > 0) {
                bullishCount++;
            }
        }
        
        if (mlPrediction != null) {
            totalPredictions++;
            if (mlPrediction.compareTo(currentPrice) > 0) {
                bullishCount++;
            }
        }
        
        if (trendPrediction != null) {
            totalPredictions++;
            if (trendPrediction.compareTo(currentPrice) > 0) {
                bullishCount++;
            }
        }
        
        return totalPredictions > 0 && (bullishCount * 2) > totalPredictions; // Majority bullish
    }
    
    /**
     * Check if predictions are bearish
     */
    public boolean arePredictionsBearish() {
        if (currentPrice == null) {
            return false;
        }
        
        int bearishCount = 0;
        int totalPredictions = 0;
        
        if (arimaPrediction != null) {
            totalPredictions++;
            if (arimaPrediction.compareTo(currentPrice) < 0) {
                bearishCount++;
            }
        }
        
        if (mlPrediction != null) {
            totalPredictions++;
            if (mlPrediction.compareTo(currentPrice) < 0) {
                bearishCount++;
            }
        }
        
        if (trendPrediction != null) {
            totalPredictions++;
            if (trendPrediction.compareTo(currentPrice) < 0) {
                bearishCount++;
            }
        }
        
        return totalPredictions > 0 && (bearishCount * 2) > totalPredictions; // Majority bearish
    }
    
    /**
     * Get average prediction price
     */
    public BigDecimal getAveragePrediction() {
        BigDecimal sum = BigDecimal.ZERO;
        int count = 0;
        
        if (arimaPrediction != null) {
            sum = sum.add(arimaPrediction);
            count++;
        }
        
        if (mlPrediction != null) {
            sum = sum.add(mlPrediction);
            count++;
        }
        
        if (trendPrediction != null) {
            sum = sum.add(trendPrediction);
            count++;
        }
        
        return count > 0 ? sum.divide(BigDecimal.valueOf(count), 8, java.math.RoundingMode.HALF_UP) : null;
    }
}
