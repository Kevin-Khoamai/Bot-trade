package com.cryptotrading.strategy.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Trading signal generated by strategy rules
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class TradingSignal {

    private String symbol;
    private StrategyExecution.TradeSide side;
    private SignalType signalType;
    private SignalStrength strength;
    
    // Order Details
    private BigDecimal quantity;
    private BigDecimal entryPrice;
    private BigDecimal stopLossPrice;
    private BigDecimal takeProfitPrice;
    
    // Signal Metadata
    private String reason;
    private BigDecimal confidence;
    private LocalDateTime timestamp;
    private String strategyName;
    
    // Risk Management
    private BigDecimal maxRisk;
    private BigDecimal riskRewardRatio;
    private BigDecimal positionSizePercent;
    
    // Technical Context
    private String technicalSetup;
    private String marketCondition;
    private BigDecimal volatility;
    
    /**
     * Signal types
     */
    public enum SignalType {
        ENTRY_LONG,         // Open long position
        ENTRY_SHORT,        // Open short position
        EXIT_LONG,          // Close long position
        EXIT_SHORT,         // Close short position
        SCALE_IN,           // Add to existing position
        SCALE_OUT,          // Reduce existing position
        STOP_LOSS,          // Stop loss trigger
        TAKE_PROFIT,        // Take profit trigger
        REBALANCE           // Portfolio rebalancing
    }
    
    /**
     * Signal strength levels
     */
    public enum SignalStrength {
        WEAK(0.3),
        MODERATE(0.5),
        STRONG(0.7),
        VERY_STRONG(0.9);
        
        private final double value;
        
        SignalStrength(double value) {
            this.value = value;
        }
        
        public double getValue() {
            return value;
        }
        
        public BigDecimal getBigDecimalValue() {
            return BigDecimal.valueOf(value);
        }
    }
    
    /**
     * Create a buy signal
     */
    public static TradingSignal createBuySignal(String symbol, BigDecimal quantity, 
                                               BigDecimal entryPrice, String reason) {
        return TradingSignal.builder()
                .symbol(symbol)
                .side(StrategyExecution.TradeSide.BUY)
                .signalType(SignalType.ENTRY_LONG)
                .quantity(quantity)
                .entryPrice(entryPrice)
                .reason(reason)
                .timestamp(LocalDateTime.now())
                .strength(SignalStrength.MODERATE)
                .confidence(BigDecimal.valueOf(0.7))
                .build();
    }
    
    /**
     * Create a sell signal
     */
    public static TradingSignal createSellSignal(String symbol, BigDecimal quantity, 
                                                BigDecimal entryPrice, String reason) {
        return TradingSignal.builder()
                .symbol(symbol)
                .side(StrategyExecution.TradeSide.SELL)
                .signalType(SignalType.ENTRY_SHORT)
                .quantity(quantity)
                .entryPrice(entryPrice)
                .reason(reason)
                .timestamp(LocalDateTime.now())
                .strength(SignalStrength.MODERATE)
                .confidence(BigDecimal.valueOf(0.7))
                .build();
    }
    
    /**
     * Create an exit signal
     */
    public static TradingSignal createExitSignal(String symbol, BigDecimal quantity, 
                                                BigDecimal exitPrice, String reason,
                                                StrategyExecution.TradeSide originalSide) {
        SignalType exitType = originalSide == StrategyExecution.TradeSide.BUY 
                            ? SignalType.EXIT_LONG 
                            : SignalType.EXIT_SHORT;
        
        StrategyExecution.TradeSide exitSide = originalSide == StrategyExecution.TradeSide.BUY 
                                             ? StrategyExecution.TradeSide.SELL 
                                             : StrategyExecution.TradeSide.BUY;
        
        return TradingSignal.builder()
                .symbol(symbol)
                .side(exitSide)
                .signalType(exitType)
                .quantity(quantity)
                .entryPrice(exitPrice)
                .reason(reason)
                .timestamp(LocalDateTime.now())
                .strength(SignalStrength.MODERATE)
                .confidence(BigDecimal.valueOf(0.7))
                .build();
    }
    
    /**
     * Create a stop loss signal
     */
    public static TradingSignal createStopLossSignal(String symbol, BigDecimal quantity, 
                                                    BigDecimal stopPrice, String reason) {
        return TradingSignal.builder()
                .symbol(symbol)
                .side(StrategyExecution.TradeSide.SELL)
                .signalType(SignalType.STOP_LOSS)
                .quantity(quantity)
                .entryPrice(stopPrice)
                .reason(reason)
                .timestamp(LocalDateTime.now())
                .strength(SignalStrength.VERY_STRONG)
                .confidence(BigDecimal.valueOf(0.95))
                .build();
    }
    
    /**
     * Create a take profit signal
     */
    public static TradingSignal createTakeProfitSignal(String symbol, BigDecimal quantity, 
                                                      BigDecimal profitPrice, String reason) {
        return TradingSignal.builder()
                .symbol(symbol)
                .side(StrategyExecution.TradeSide.SELL)
                .signalType(SignalType.TAKE_PROFIT)
                .quantity(quantity)
                .entryPrice(profitPrice)
                .reason(reason)
                .timestamp(LocalDateTime.now())
                .strength(SignalStrength.STRONG)
                .confidence(BigDecimal.valueOf(0.8))
                .build();
    }
    
    /**
     * Check if signal is an entry signal
     */
    public boolean isEntrySignal() {
        return signalType == SignalType.ENTRY_LONG || signalType == SignalType.ENTRY_SHORT;
    }
    
    /**
     * Check if signal is an exit signal
     */
    public boolean isExitSignal() {
        return signalType == SignalType.EXIT_LONG || 
               signalType == SignalType.EXIT_SHORT ||
               signalType == SignalType.STOP_LOSS ||
               signalType == SignalType.TAKE_PROFIT;
    }
    
    /**
     * Check if signal is bullish
     */
    public boolean isBullish() {
        return signalType == SignalType.ENTRY_LONG || 
               signalType == SignalType.EXIT_SHORT;
    }
    
    /**
     * Check if signal is bearish
     */
    public boolean isBearish() {
        return signalType == SignalType.ENTRY_SHORT || 
               signalType == SignalType.EXIT_LONG;
    }
    
    /**
     * Check if signal has high confidence
     */
    public boolean hasHighConfidence() {
        return confidence != null && confidence.compareTo(BigDecimal.valueOf(0.8)) >= 0;
    }
    
    /**
     * Check if signal is strong
     */
    public boolean isStrongSignal() {
        return strength == SignalStrength.STRONG || strength == SignalStrength.VERY_STRONG;
    }
    
    /**
     * Calculate position size based on risk percentage
     */
    public BigDecimal calculatePositionSize(BigDecimal accountBalance, BigDecimal riskPercent) {
        if (accountBalance == null || riskPercent == null || stopLossPrice == null || entryPrice == null) {
            return quantity; // Return default quantity if calculation not possible
        }
        
        BigDecimal riskAmount = accountBalance.multiply(riskPercent.divide(BigDecimal.valueOf(100)));
        BigDecimal priceRisk = entryPrice.subtract(stopLossPrice).abs();
        
        if (priceRisk.compareTo(BigDecimal.ZERO) == 0) {
            return quantity;
        }
        
        return riskAmount.divide(priceRisk, 8, java.math.RoundingMode.HALF_UP);
    }
    
    /**
     * Calculate risk-reward ratio
     */
    public BigDecimal calculateRiskRewardRatio() {
        if (entryPrice == null || stopLossPrice == null || takeProfitPrice == null) {
            return null;
        }
        
        BigDecimal risk = entryPrice.subtract(stopLossPrice).abs();
        BigDecimal reward = takeProfitPrice.subtract(entryPrice).abs();
        
        if (risk.compareTo(BigDecimal.ZERO) == 0) {
            return null;
        }
        
        return reward.divide(risk, 4, java.math.RoundingMode.HALF_UP);
    }
    
    /**
     * Validate signal parameters
     */
    public boolean isValid() {
        return symbol != null && 
               side != null && 
               signalType != null && 
               quantity != null && 
               quantity.compareTo(BigDecimal.ZERO) > 0 &&
               entryPrice != null && 
               entryPrice.compareTo(BigDecimal.ZERO) > 0;
    }
    
    /**
     * Get signal priority based on type and strength
     */
    public int getPriority() {
        // Higher number = higher priority
        int basePriority = switch (signalType) {
            case STOP_LOSS -> 100;
            case TAKE_PROFIT -> 90;
            case EXIT_LONG, EXIT_SHORT -> 80;
            case ENTRY_LONG, ENTRY_SHORT -> 70;
            case SCALE_OUT -> 60;
            case SCALE_IN -> 50;
            case REBALANCE -> 40;
        };
        
        int strengthBonus = switch (strength) {
            case VERY_STRONG -> 20;
            case STRONG -> 15;
            case MODERATE -> 10;
            case WEAK -> 5;
        };
        
        return basePriority + strengthBonus;
    }
}
